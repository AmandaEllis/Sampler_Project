#Function that generates a new X
#New X is generated by performing 1 or 3 options
# A. Create New Individual
# B. Delete an Individual
# C. Move photos


new.X.create<-function(X,t,lambda,p){
  
  #Number of indidivduals in current X
  current.n.ind<-max(X[,3]) 
  new.X<-X
  
  #delete keeps track of if we delete an individual
  #If an individual is deleted then we do not accept the candidate X
  delete='FALSE'  
  
  #Simulate capture history for new individual
  #Select number of occasions individual is seen on and which occasions using the current value of p
  #The individual must be observed on at least one occasion
  
  #Start with the capture occasion being all zero.
  all.zero<-TRUE
  
  #Simulate until capture occasion has at least 1 capture
  while(all.zero==TRUE){
    w<-rep(NA,length=t)
    for (j in 1:t){
      w[j]<-rbinom(1,size=1,prob=p[j])
    }
    n.occasion<-sum(w)
    occasions<-which(w==1)
    if(n.occasion >0){all.zero=FALSE}
  }
  
  #Next we select the ID for the individual
  new.individual<-sample(seq(from=.5,to=(current.n.ind+.5),by=1),1)
      
  #Renumber the individuals
  new.X[which(new.X[,3]>new.individual),3]=new.X[which(new.X[,3]>new.individual),3]+1
      
  #For each of the occasions the indidivual is seen on we pull photos from other individuals
  #For each occasion we simulate the number of photos using the current value of lambda
    
  for(i in 1:n.occasion){
      #Select number of photos to remove
      n.photos<-rtpois(1,lambda)
      ##Select the location of photos to be removed
      remove.location<-sample(X[which(X[,2]==occasions[i]),1],n.photos)
      #Sets the location of the photos to the new indidivual
      new.X[remove.location,3]<-new.individual+.5
      }
      
  #Need to account for when all of the photos are removed for an individual
  if(length(unique(new.X[,3])) != (current.n.ind+1)) {
     new.X=X
     delete='TRUE'
     }

    return(list("new.X"=new.X,'photos'=remove.location,'new.ID'=(new.individual+.5),'delete'=delete))
    
}